+++
title = "Using Honeycomb"
time = 180
objectives = [
  "Publish trace spans to Honeycomb.",
  "View an assembled trace in Honeycomb.",
  "Identify outliers in Honeycomb.",
]
[build]
  render = "never"
  list = "local"
  publishResources = false
+++

[Honeycomb](https://www.honeycomb.io/) is a {{<tooltip title="SaaS">}}Software as a Service is software that someone else runs and we can rely on. {{</tooltip>}} distributed tracing provider.

Honeycomb provide API endpoints where we can upload trace spans. Honeycomb assembles spans which belong to the same traces. We can then view, query, and inspect those entire traces, seeing how our request flowed through a system.

We will experiment with Honeycomb locally with a single program running on one computer, to practice uploading and interpreting spans.

Sign up to Honeycomb for free.

{{<note type="Exercise">}}
Write a small standalone command line application which:
1. Picks a random number of iterations between 2 and 10 (we'll call it `n`).
2. `n` times, creates a span, sleeps for a random amount of time between 10ms and 5s, then uploads the span.
3. Between each span, sleeps for a random amount of time between 100ms and 5s.

Each time you run your program, it should use a unique trace ID, but within on program execution, all spans should have the same trace ID.

There are standard libraries for creating and sending OTel spans, such as [in Go](https://docs.honeycomb.io/send-data/go/opentelemetry-sdk/) and [in Java](https://docs.honeycomb.io/send-data/java/opentelemetry-agent/).
{{</note>}}

{{<note type="Exercise">}}
Run your program 10 times, making sure it uploads its spans to Honeycomb with your API key.

Explore the Honeycomb UI. Try to work out:
1. What was the biggest `n` generated by one of your program runs?
2. Which was the fastest run? What was `n` for that run?
3. What was the longest individual sleep performed in your program during a span?
4. What was the longest individual sleep _between_ spans in your program?
{{</note>}}
