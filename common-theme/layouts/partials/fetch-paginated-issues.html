{{/* # This is a recursive partial
  # The point is to walk the paginated issues
  # So we don't lose coursework tasks pushed off page 1 as pull requests start piling up
*/}}
{{/* set the current page we are getting */}}
{{ $issuesUrl := print .issuesUrlBase .page }}
{{/* fetch the issues using the new style in v0.127 */}}
{{ $pageOfIssues := resources.GetRemote $issuesUrl .headers }}

{{ if eq nil $pageOfIssues }}
  {{ errorf "ğŸ·ï¸ Issues not fetched: API at %s returned nil" $issuesUrl }}
{{ else if $pageOfIssues.Err }}
  {{ errorf "ğŸ·ï¸ Issues not fetched: %s" $pageOfIssues.Err }}
{{ else }}
  {{ if ne $pageOfIssues nil }}
    {{ $pageOfIssues = $pageOfIssues.Content | transform.Unmarshal }}

    {{/* get the issues we have so far in our Scratch.
      This how we make these issues available to our parent partial issues.html
    */}}
    {{ $fetchedIssues := .Scratch.Get "issues" }}
    {{ .Scratch.Set "issues" (append $fetchedIssues $pageOfIssues) }}
    {{/* If we got 100 issues, there might be more. Let's fetch the next page */}}
    {{ if eq (len $pageOfIssues) 99 }}
      {{ $nextPage := add .page 1 }}
      {{ partial "fetch-paginated-issues.html" (dict "Scratch" .Scratch "issuesUrlBase" .issuesUrlBase  "page" $nextPage "headers" .headers ) }}
    {{ end }}
  {{ end }}
{{ end }}
